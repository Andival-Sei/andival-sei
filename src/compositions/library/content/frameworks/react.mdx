# React: Современная библиотека для UI

React — это JavaScript библиотека для создания пользовательских интерфейсов с использованием компонентного подхода.

## Компоненты и Props

Компоненты — строительные блоки React приложений.

### Функциональные компоненты

```tsx
import { type ReactNode } from "react";

// Простой компонент
function Welcome() {
  return <h1>Привет, мир!</h1>;
}

// Компонент с props
type ButtonProps = {
  children: ReactNode;
  variant?: "primary" | "secondary";
  onClick?: () => void;
};

function Button({ children, variant = "primary", onClick }: ButtonProps) {
  return (
    <button className={`btn btn-${variant}`} onClick={onClick}>
      {children}
    </button>
  );
}

// Использование
<Button variant="primary" onClick={() => console.log("Clicked!")}>
  Нажми меня
</Button>;
```

### Деструктуризация и значения по умолчанию

```tsx
type UserCardProps = {
  name: string;
  age?: number;
  role?: string;
  avatar?: string;
};

function UserCard({
  name,
  age = 18,
  role = "User",
  avatar = "/default-avatar.png",
}: UserCardProps) {
  return (
    <div className="user-card">
      <img src={avatar} alt={name} />
      <h3>{name}</h3>
      <p>Возраст: {age}</p>
      <span>{role}</span>
    </div>
  );
}
```

## Хуки (Hooks)

Хуки позволяют использовать состояние и другие возможности React в функциональных компонентах.

### useState - управление состоянием

```tsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
      <button onClick={() => setCount((prev) => prev - 1)}>-1</button>
      <button onClick={() => setCount(0)}>Сброс</button>
    </div>
  );
}

// Сложное состояние
type FormData = {
  username: string;
  email: string;
  age: number;
};

function UserForm() {
  const [formData, setFormData] = useState<FormData>({
    username: "",
    email: "",
    age: 0,
  });

  const handleChange = (field: keyof FormData, value: string | number) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  return (
    <form>
      <input
        value={formData.username}
        onChange={(e) => handleChange("username", e.target.value)}
      />
      {/* ... */}
    </form>
  );
}
```

### useEffect - побочные эффекты

```tsx
import { useEffect, useState } from "react";

function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Этот эффект запускается при изменении userId
    let cancelled = false;

    async function fetchUser() {
      setLoading(true);
      try {
        const response = await fetch(`/api/users/${userId}`);
        const data = await response.json();

        if (!cancelled) {
          setUser(data);
        }
      } catch (error) {
        console.error("Error fetching user:", error);
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    }

    fetchUser();

    // Cleanup функция
    return () => {
      cancelled = true;
    };
  }, [userId]); // Зависимости

  if (loading) return <div>Загрузка...</div>;
  if (!user) return <div>Пользователь не найден</div>;

  return <div>{/* Рендер пользователя */}</div>;
}
```

### useEffect patterns

```tsx
// 1. Выполнить один раз при монтировании
useEffect(() => {
  console.log("Component mounted");
}, []); // Пустой массив зависимостей

// 2. Выполнять при каждом рендере (обычно избегаем)
useEffect(() => {
  console.log("Component rendered");
}); // Без массива зависимостей

// 3. Cleanup при размонтировании
useEffect(() => {
  const interval = setInterval(() => {
    console.log("Tick");
  }, 1000);

  return () => {
    clearInterval(interval);
  };
}, []);

// 4. Подписка на события
useEffect(() => {
  function handleResize() {
    console.log("Window resized");
  }

  window.addEventListener("resize", handleResize);

  return () => {
    window.removeEventListener("resize", handleResize);
  };
}, []);
```

### useMemo - мемоизация значений

```tsx
import { useMemo } from "react";

function ExpensiveComponent({ items }: { items: number[] }) {
  // Дорогая операция выполнится только при изменении items
  const sortedItems = useMemo(() => {
    console.log("Sorting items...");
    return [...items].sort((a, b) => a - b);
  }, [items]);

  const total = useMemo(() => {
    return items.reduce((sum, item) => sum + item, 0);
  }, [items]);

  return (
    <div>
      <p>Всего элементов: {total}</p>
      <ul>
        {sortedItems.map((item) => (
          <li key={item}>{item}</li>
        ))}
      </ul>
    </div>
  );
}
```

### useCallback - мемоизация функций

```tsx
import { useCallback, useState, memo } from "react";

// Дочерний компонент, обернутый в memo
const ChildComponent = memo(({ onClick }: { onClick: () => void }) => {
  console.log("Child rendered");
  return <button onClick={onClick}>Нажми меня</button>;
});

function ParentComponent() {
  const [count, setCount] = useState(0);
  const [other, setOther] = useState(0);

  // Функция не пересоздается при изменении 'other'
  const handleClick = useCallback(() => {
    setCount((prev) => prev + 1);
  }, []); // Зависимости

  return (
    <div>
      <p>Count: {count}</p>
      <p>Other: {other}</p>
      <ChildComponent onClick={handleClick} />
      <button onClick={() => setOther((prev) => prev + 1)}>
        Изменить other
      </button>
    </div>
  );
}
```

### useRef - ссылки на DOM и мутабельные значения

```tsx
import { useRef, useEffect } from "react";

function TextInputWithFocus() {
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    // Фокус при монтировании
    inputRef.current?.focus();
  }, []);

  return <input ref={inputRef} type="text" />;
}

// Хранение мутабельного значения без ререндера
function Timer() {
  const [count, setCount] = useState(0);
  const intervalRef = useRef<number | null>(null);

  const startTimer = () => {
    if (intervalRef.current !== null) return;

    intervalRef.current = window.setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);
  };

  const stopTimer = () => {
    if (intervalRef.current !== null) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };

  useEffect(() => {
    return () => stopTimer(); // Cleanup
  }, []);

  return (
    <div>
      <p>Секунд: {count}</p>
      <button onClick={startTimer}>Старт</button>
      <button onClick={stopTimer}>Стоп</button>
    </div>
  );
}
```

## Context API

Context позволяет передавать данные через дерево компонентов без props drilling.

### Создание и использование контекста

```tsx
import { createContext, useContext, useState, type ReactNode } from "react";

// 1. Создаем контекст
type Theme = "light" | "dark";

type ThemeContextType = {
  theme: Theme;
  toggleTheme: () => void;
};

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// 2. Создаем Provider
function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<Theme>("light");

  const toggleTheme = () => {
    setTheme((prev) => (prev === "light" ? "dark" : "light"));
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// 3. Создаем custom hook для удобства
function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error("useTheme must be used within ThemeProvider");
  }
  return context;
}

// 4. Используем в компонентах
function ThemeToggle() {
  const { theme, toggleTheme } = useTheme();

  return <button onClick={toggleTheme}>Текущая тема: {theme}</button>;
}

// 5. Оборачиваем приложение
function App() {
  return (
    <ThemeProvider>
      <div>
        <ThemeToggle />
        {/* Остальные компоненты */}
      </div>
    </ThemeProvider>
  );
}
```

## Оптимизация рендера

### React.memo

```tsx
import { memo } from "react";

type ItemProps = {
  id: number;
  title: string;
  onClick: (id: number) => void;
};

// Компонент не ререндерится, если props не изменились
const ListItem = memo(({ id, title, onClick }: ItemProps) => {
  console.log(`Rendering item ${id}`);
  return <li onClick={() => onClick(id)}>{title}</li>;
});

// С кастомным сравнением
const OptimizedItem = memo(
  ({ id, title, onClick }: ItemProps) => {
    return <li onClick={() => onClick(id)}>{title}</li>;
  },
  (prevProps, nextProps) => {
    // Вернуть true если props равны (не ререндерить)
    return prevProps.id === nextProps.id && prevProps.title === nextProps.title;
  }
);
```

### Lazy loading компонентов

```tsx
import { lazy, Suspense } from "react";

// Ленивая загрузка компонента
const HeavyComponent = lazy(() => import("./HeavyComponent"));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Загрузка...</div>}>
        <HeavyComponent />
      </Suspense>
    </div>
  );
}
```

## Паттерны

### Compound Components

```tsx
import { createContext, useContext, useState, type ReactNode } from "react";

// Контекст для Tabs
const TabsContext = createContext<
  | {
      activeTab: string;
      setActiveTab: (tab: string) => void;
    }
  | undefined
>(undefined);

function Tabs({
  children,
  defaultTab,
}: {
  children: ReactNode;
  defaultTab: string;
}) {
  const [activeTab, setActiveTab] = useState(defaultTab);

  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
}

function TabList({ children }: { children: ReactNode }) {
  return <div className="tab-list">{children}</div>;
}

function Tab({ value, children }: { value: string; children: ReactNode }) {
  const context = useContext(TabsContext);
  if (!context) throw new Error("Tab must be used within Tabs");

  const { activeTab, setActiveTab } = context;

  return (
    <button
      className={activeTab === value ? "active" : ""}
      onClick={() => setActiveTab(value)}
    >
      {children}
    </button>
  );
}

function TabPanel({ value, children }: { value: string; children: ReactNode }) {
  const context = useContext(TabsContext);
  if (!context) throw new Error("TabPanel must be used within Tabs");

  const { activeTab } = context;

  if (activeTab !== value) return null;

  return <div className="tab-panel">{children}</div>;
}

// Использование
function App() {
  return (
    <Tabs defaultTab="profile">
      <TabList>
        <Tab value="profile">Профиль</Tab>
        <Tab value="settings">Настройки</Tab>
      </TabList>

      <TabPanel value="profile">
        <h2>Профиль пользователя</h2>
      </TabPanel>

      <TabPanel value="settings">
        <h2>Настройки</h2>
      </TabPanel>
    </Tabs>
  );
}
```

### Render Props

```tsx
type MousePosition = { x: number; y: number };

function MouseTracker({
  children,
}: {
  children: (position: MousePosition) => ReactNode;
}) {
  const [position, setPosition] = useState<MousePosition>({ x: 0, y: 0 });

  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };

    window.addEventListener("mousemove", handleMouseMove);
    return () => window.removeEventListener("mousemove", handleMouseMove);
  }, []);

  return <>{children(position)}</>;
}

// Использование
<MouseTracker>
  {({ x, y }) => (
    <div>
      Позиция мыши: {x}, {y}
    </div>
  )}
</MouseTracker>;
```

## Полезные ресурсы

- [React Documentation](https://react.dev/)
- [React TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app/)
- [Patterns.dev](https://www.patterns.dev/react/) - паттерны React
- [usehooks.com](https://usehooks.com/) - коллекция custom hooks
